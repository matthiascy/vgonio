use crate::params::GafMeasurementParams;
use vgonio_core::{
    impl_any_measured_trait, units::Radians, utils::range::StepRangeIncl, MeasurementKind,
};

/// Structure holding the data for microfacet shadowing and masking measurement.
///
/// G(i, o, m) is the micro facet masking-shadowing function, which describes
/// the fraction of micro-facets with normal m that are visible from both the
/// incident direction i and the outgoing direction o.
///
/// The Smith microfacet masking-shadowing function is defined as:
///
/// G(i, o, m) = G1(i, m) * G1(o, m)
///
/// This structure holds the data for G1(i, m).
#[derive(Debug, Clone)]
pub struct MeasuredGafData {
    /// The measurement parameters.
    pub params: GafMeasurementParams,
    /// The distribution data. The outermost dimension is the view direction
    /// (microfacet normal) generated by the azimuthal and zenith angle
    /// (azimuth first then zenith). The innermost dimension is the
    /// visibility data for each incident direction.
    pub samples: Box<[f32]>,
}

impl_any_measured_trait!(MeasuredGafData, Gaf);

impl MeasuredGafData {
    // TODO: review the necessity of this method.
    /// Returns the measurement range of the azimuthal and zenith angles.
    /// The azimuthal angle is in the range 0 ~ 2π, and the zenith angle is in
    /// the range 0 ~ π/2.
    pub fn measurement_range(&self) -> (StepRangeIncl<Radians>, StepRangeIncl<Radians>) {
        (self.params.azimuth, self.params.zenith)
    }

    /// Returns the Masking Shadowing Function data slice for the given
    /// microfacet normal and azimuthal angle of the incident direction.
    ///
    /// The returned slice contains two elements, the first one is the
    /// data slice for the given azimuthal angle, the second one is the
    /// data slice for the azimuthal angle that is 180 degrees away from
    /// the given azimuthal angle, if it exists.
    pub fn slice_at(
        &self,
        azim_m: Radians,
        zeni_m: Radians,
        azim_i: Radians,
    ) -> (&[f32], Option<&[f32]>) {
        let azimuth_m = azim_m.wrap_to_tau();
        let azimuth_i = azim_i.wrap_to_tau();
        let zenith_m = zeni_m.clamp(self.params.zenith.start, self.params.zenith.stop);
        let azimuth_m_idx = self.params.azimuth.index_of(azimuth_m);
        let zenith_m_idx = self.params.zenith.index_of(zenith_m);
        let azimuth_i_idx = self.params.azimuth.index_of(azimuth_i);
        let opposite_azimuth_i = azimuth_i.opposite();
        let opposite_azimuth_i_idx = if self.params.azimuth.start <= opposite_azimuth_i
            && opposite_azimuth_i <= self.params.azimuth.stop
        {
            Some(self.params.azimuth.index_of(opposite_azimuth_i))
        } else {
            None
        };
        (
            self.slice_at_indices(azimuth_m_idx, zenith_m_idx, azimuth_i_idx),
            opposite_azimuth_i_idx
                .map(|index| self.slice_at_indices(azimuth_m_idx, zenith_m_idx, index)),
        )
    }

    /// Returns a data slice of the Masking Shadowing Function for the given
    /// indices.
    fn slice_at_indices(
        &self,
        azimuth_m_idx: usize,
        zenith_m_idx: usize,
        azimuth_i_idx: usize,
    ) -> &[f32] {
        debug_assert!(self.kind() == MeasurementKind::Gaf);
        debug_assert!(
            azimuth_m_idx < self.params.azimuth.step_count_wrapped(),
            "index out of range"
        );
        debug_assert!(
            azimuth_i_idx < self.params.azimuth.step_count_wrapped(),
            "index out of range"
        );
        debug_assert!(
            zenith_m_idx < self.params.zenith.step_count_wrapped(),
            "index out of range"
        );
        let zenith_bin_count = self.params.zenith.step_count_wrapped();
        let azimuth_bin_count = self.params.azimuth.step_count_wrapped();
        let offset = azimuth_m_idx * zenith_bin_count * azimuth_bin_count * zenith_bin_count
            + zenith_m_idx * azimuth_bin_count * zenith_bin_count
            + azimuth_i_idx * zenith_bin_count;
        &self.samples[offset..offset + zenith_bin_count]
    }
}
